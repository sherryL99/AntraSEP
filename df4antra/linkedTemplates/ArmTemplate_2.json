{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "df4antra"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/hardcodeIncrementalCopy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "LookupOldWatermark",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "select * from watermarktable where TableName  =  'Sales.Orders'",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "watermarkDataset",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "LookupNewWatermark",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "select MAX(LastEditedWhen) as NewWatermarkvalue from Sales.Orders",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "Orders",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "LookupOldWatermark",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "LookupNewWatermark",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": {
									"value": "select * from Sales.Orders where  LastEditedWhen> '@{activity('LookupOldWatermark').output.firstRow.WatermarkValue}' and LastEditedWhen <= '@{activity('LookupNewWatermark').output.firstRow.NewWatermarkvalue}'",
									"type": "Expression"
								},
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"sink": {
								"type": "AzureSqlSink",
								"sqlWriterStoredProcedureName": "[[dbo].[usp_upsert_order_table]",
								"sqlWriterTableType": "DataTypeforOrdersTable",
								"storedProcedureTableTypeParameterName": "Orders",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Orders",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ouptutOrders",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Stored procedure1",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[dbo].[usp_write_watermark]",
							"storedProcedureParameters": {
								"LastEditedWhen": {
									"value": {
										"value": "@{activity('LookupNewWatermark').output.firstRow.NewWatermarkvalue}",
										"type": "Expression"
									},
									"type": "DateTime"
								},
								"TableName": {
									"value": {
										"value": "@{activity('LookupOldWatermark').output.firstRow.TableName}",
										"type": "Expression"
									},
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "AzureSqlDatabase1",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/BronzeToSilver')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "bronzeMovie",
								"type": "DatasetReference"
							},
							"name": "IngestBronze"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "MovieSilver",
								"type": "DatasetReference"
							},
							"name": "MovieSilver"
						},
						{
							"dataset": {
								"referenceName": "BronzeToSilver",
								"type": "DatasetReference"
							},
							"name": "sink3"
						},
						{
							"dataset": {
								"referenceName": "BronzeToSilver",
								"type": "DatasetReference"
							},
							"name": "sink5"
						}
					],
					"transformations": [
						{
							"name": "filterStatusNew"
						},
						{
							"name": "selectMovie"
						},
						{
							"name": "selectGenres"
						},
						{
							"name": "selectLanguage"
						},
						{
							"name": "flattenGenres"
						},
						{
							"name": "split1"
						},
						{
							"name": "LitStatusLoaded"
						},
						{
							"name": "LitStatusQuarantined"
						},
						{
							"name": "selectData"
						},
						{
							"name": "DeduplicateGenres"
						},
						{
							"name": "split2"
						},
						{
							"name": "LitStatusLoadedGenres"
						},
						{
							"name": "TransformGenres"
						},
						{
							"name": "LitStatusQuarantinedGenres"
						},
						{
							"name": "ChangeValue"
						},
						{
							"name": "selectJoinedData"
						},
						{
							"name": "LitStatusQuarantineLoadedGenres"
						},
						{
							"name": "split3"
						},
						{
							"name": "LitStatusLoadedLanguage"
						},
						{
							"name": "ChangeMovieValue"
						},
						{
							"name": "LitMovieQuarantineLoaded"
						},
						{
							"name": "ChangeValueLanguage"
						},
						{
							"name": "union1"
						},
						{
							"name": "union2"
						},
						{
							"name": "union3"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as (Id as integer, Title as string, Overview as string, Tagline as string, Budget as double, Revenue as double, ImdbUrl as string, TmdbUrl as string, PosterUrl as string, BackdropUrl as string, OriginalLanguage as string, ReleaseDate as string, RunTime as integer, Price as double, CreatedDate as string, UpdatedDate as string, UpdatedBy as string, CreatedBy as string, genres as (id as integer, name as string)[]),",
						"          datasource as string,",
						"          status as string,",
						"          ingestdate as date,",
						"          ingesttime as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> IngestBronze",
						"IngestBronze filter(status=='new') ~> filterStatusNew",
						"selectData select(mapColumn(",
						"          Id,",
						"          Title,",
						"          Overview,",
						"          Tagline,",
						"          Budget,",
						"          Revenue,",
						"          ImdbUrl,",
						"          TmdbUrl,",
						"          PosterUrl,",
						"          BackdropUrl,",
						"          OriginalLanguage,",
						"          ReleaseDate,",
						"          RunTime,",
						"          Price,",
						"          CreatedDate,",
						"          UpdatedDate,",
						"          UpdatedBy,",
						"          CreatedBy,",
						"          genres,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectMovie",
						"selectData select(mapColumn(",
						"          genres,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenres",
						"selectData select(mapColumn(",
						"          OriginalLanguage,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectLanguage",
						"selectGenres foldDown(unroll(genres),",
						"     mapColumn(",
						"          genres_id = genres.id,",
						"          genres_name = genres.name,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime,",
						"          genres",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenres",
						"selectMovie split(and(Budget>1000000, RunTime>0),",
						"     disjoint: false) ~> split1@(MovieSilverClean, MovieSilverQuarantine)",
						"split1@MovieSilverClean derive(status = 'loaded') ~> LitStatusLoaded",
						"split1@MovieSilverQuarantine derive(status = 'quarantined') ~> LitStatusQuarantined",
						"filterStatusNew select(mapColumn(",
						"          movie,",
						"          Id = movie.Id,",
						"          Title = movie.Title,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime,",
						"          Overview = movie.Overview,",
						"          Tagline = movie.Tagline,",
						"          Budget = movie.Budget,",
						"          Revenue = movie.Revenue,",
						"          ImdbUrl = movie.ImdbUrl,",
						"          TmdbUrl = movie.TmdbUrl,",
						"          PosterUrl = movie.PosterUrl,",
						"          BackdropUrl = movie.BackdropUrl,",
						"          OriginalLanguage = movie.OriginalLanguage,",
						"          ReleaseDate = movie.ReleaseDate,",
						"          RunTime = movie.RunTime,",
						"          Price = movie.Price,",
						"          CreatedDate = movie.CreatedDate,",
						"          UpdatedDate = movie.UpdatedDate,",
						"          UpdatedBy = movie.UpdatedBy,",
						"          CreatedBy = movie.CreatedBy,",
						"          genres = movie.genres",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectData",
						"flattenGenres aggregate(groupBy(genres_id),",
						"     genres_name = first(genres_name)) ~> DeduplicateGenres",
						"flattenGenres split(not(isNull(genres_name)),",
						"     disjoint: false) ~> split2@(GenresSilverClean, GenresSilverQurantine)",
						"TransformGenres derive(status = 'loaded') ~> LitStatusLoadedGenres",
						"split2@GenresSilverClean select(mapColumn(",
						"          genres,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> TransformGenres",
						"split2@GenresSilverQurantine derive(status = 'quarantined') ~> LitStatusQuarantinedGenres",
						"LitStatusQuarantinedGenres, DeduplicateGenres join(split2@GenresSilverQurantine@genres_id == DeduplicateGenres@genres_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> ChangeValue",
						"ChangeValue select(mapColumn(",
						"          genres,",
						"          genres_id = DeduplicateGenres@genres_id,",
						"          genres_name = DeduplicateGenres@genres_name,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectJoinedData",
						"selectJoinedData derive(status = 'loaded') ~> LitStatusQuarantineLoadedGenres",
						"selectLanguage split(not(isNull(OriginalLanguage)),",
						"     disjoint: false) ~> split3@(LanguageSilverClean, LanguageSilverQuarantine)",
						"split3@LanguageSilverClean derive(status = 'loaded') ~> LitStatusLoadedLanguage",
						"LitStatusQuarantined derive(RunTime = abs(RunTime),",
						"          Budget = 1000000) ~> ChangeMovieValue",
						"ChangeMovieValue derive(status = 'loaded') ~> LitMovieQuarantineLoaded",
						"split3@LanguageSilverQuarantine derive(OriginalLanguage = 'en') ~> ChangeValueLanguage",
						"LitStatusLoadedLanguage, ChangeValueLanguage union(byName: true)~> union1",
						"select1, LitStatusQuarantineLoadedGenres union(byName: true)~> union2",
						"LitStatusLoaded, LitMovieQuarantineLoaded union(byName: true)~> union3",
						"LitStatusLoadedGenres select(mapColumn(",
						"          genres,",
						"          id = genres.id,",
						"          name = genres.name,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"union2 select(mapColumn(",
						"          genres,",
						"          id,",
						"          name,",
						"          datasource,",
						"          status,",
						"          ingestdate,",
						"          ingesttime",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"union3 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> MovieSilver",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink3",
						"union1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink5"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/RawToBronze')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "movieJson",
								"type": "DatasetReference"
							},
							"name": "IngestBronze"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "bronzeMovie",
								"type": "DatasetReference"
							},
							"name": "Bronze"
						}
					],
					"transformations": [
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as (Id as integer, Title as string, Overview as string, Tagline as string, Budget as double, Revenue as double, ImdbUrl as string, TmdbUrl as string, PosterUrl as string, BackdropUrl as string, OriginalLanguage as string, ReleaseDate as string, RunTime as integer, Price as double, CreatedDate as string, UpdatedDate as string, UpdatedBy as string, CreatedBy as string, genres as (id as integer, name as string)[])[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'singleDocument') ~> IngestBronze",
						"IngestBronze foldDown(unroll(movie),",
						"     mapColumn(",
						"          movie",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten1 derive(datasource = 'movie_0.json',",
						"          status = 'new',",
						"          ingestdate = currentDate(),",
						"          ingesttime = currentTimestamp()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     truncate: true,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> Bronze"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/WWI')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ouptutOrders",
								"type": "DatasetReference"
							},
							"name": "OrdersODS"
						},
						{
							"dataset": {
								"referenceName": "outputOrderlines",
								"type": "DatasetReference"
							},
							"name": "OrderlinesODS"
						},
						{
							"dataset": {
								"referenceName": "StockItems",
								"type": "DatasetReference"
							},
							"name": "StockItems"
						},
						{
							"dataset": {
								"referenceName": "outputPeople",
								"type": "DatasetReference"
							},
							"name": "People"
						},
						{
							"dataset": {
								"referenceName": "OutputPackageTypes",
								"type": "DatasetReference"
							},
							"name": "PackageTypes"
						},
						{
							"dataset": {
								"referenceName": "outputinvoices",
								"type": "DatasetReference"
							},
							"name": "Invoices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SalesPerStockItem",
								"type": "DatasetReference"
							},
							"name": "sink2"
						},
						{
							"dataset": {
								"referenceName": "CustomerInfo",
								"type": "DatasetReference"
							},
							"name": "sink3"
						},
						{
							"dataset": {
								"referenceName": "StockItemPackageType",
								"type": "DatasetReference"
							},
							"name": "sink4"
						}
					],
					"transformations": [
						{
							"name": "CountOrdersPerCustomer"
						},
						{
							"name": "select1"
						},
						{
							"name": "sort1"
						},
						{
							"name": "select2"
						},
						{
							"name": "join1"
						},
						{
							"name": "SalesPerStockItem"
						},
						{
							"name": "rank1"
						},
						{
							"name": "join2"
						},
						{
							"name": "PeopleName"
						},
						{
							"name": "select3"
						},
						{
							"name": "join3"
						},
						{
							"name": "select4"
						},
						{
							"name": "select5"
						},
						{
							"name": "join4"
						},
						{
							"name": "select6"
						},
						{
							"name": "select7"
						},
						{
							"name": "select8"
						},
						{
							"name": "join5"
						},
						{
							"name": "join6"
						},
						{
							"name": "select9"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderID as integer,",
						"          CustomerID as integer,",
						"          SalespersonPersonID as integer,",
						"          PickedByPersonID as integer,",
						"          ContactPersonID as integer,",
						"          BackorderOrderID as integer,",
						"          OrderDate as date,",
						"          ExpectedDeliveryDate as date,",
						"          CustomerPurchaseOrderNumber as string,",
						"          IsUndersupplyBackordered as boolean,",
						"          Comments as string,",
						"          DeliveryInstructions as string,",
						"          InternalComments as string,",
						"          PickingCompletedWhen as timestamp,",
						"          LastEditedBy as integer,",
						"          LastEditedWhen as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     waterMarkColumn: 'logDT',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrdersODS",
						"source(output(",
						"          OrderLineID as integer,",
						"          OrderID as integer,",
						"          StockItemID as integer,",
						"          Description as string,",
						"          PackageTypeID as integer,",
						"          Quantity as integer,",
						"          UnitPrice as decimal(18,2),",
						"          TaxRate as decimal(18,3),",
						"          PickedQuantity as integer,",
						"          PickingCompletedWhen as timestamp,",
						"          LastEditedBy as integer,",
						"          LastEditedWhen as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     waterMarkColumn: 'logDT',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrderlinesODS",
						"source(output(",
						"          StockItemID as integer,",
						"          StockItemName as string,",
						"          SupplierID as integer,",
						"          ColorID as integer,",
						"          UnitPackageID as integer,",
						"          OuterPackageID as integer,",
						"          Brand as string,",
						"          Size as string,",
						"          LeadTimeDays as integer,",
						"          QuantityPerOuter as integer,",
						"          IsChillerStock as boolean,",
						"          Barcode as string,",
						"          TaxRate as decimal(18,3),",
						"          UnitPrice as decimal(18,2),",
						"          RecommendedRetailPrice as decimal(18,2),",
						"          TypicalWeightPerUnit as decimal(18,3),",
						"          MarketingComments as string,",
						"          InternalComments as string,",
						"          Photo as binary,",
						"          CustomFields as string,",
						"          Tags as string,",
						"          SearchDetails as string,",
						"          LastEditedBy as integer,",
						"          ValidFrom as timestamp,",
						"          ValidTo as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     waterMarkColumn: 'logDT',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StockItems",
						"source(output(",
						"          PersonID as integer,",
						"          FullName as string,",
						"          PreferredName as string,",
						"          SearchName as string,",
						"          IsPermittedToLogon as boolean,",
						"          LogonName as string,",
						"          IsExternalLogonProvider as boolean,",
						"          HashedPassword as binary,",
						"          IsSystemUser as boolean,",
						"          IsEmployee as boolean,",
						"          IsSalesperson as boolean,",
						"          UserPreferences as string,",
						"          PhoneNumber as string,",
						"          FaxNumber as string,",
						"          EmailAddress as string,",
						"          Photo as binary,",
						"          CustomFields as string,",
						"          OtherLanguages as string,",
						"          LastEditedBy as integer,",
						"          ValidFrom as timestamp,",
						"          ValidTo as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> People",
						"source(output(",
						"          PackageTypeID as integer,",
						"          PackageTypeName as string,",
						"          LastEditedBy as integer,",
						"          ValidFrom as timestamp,",
						"          ValidTo as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> PackageTypes",
						"source(output(",
						"          InvoiceID as integer,",
						"          CustomerID as integer,",
						"          BillToCustomerID as integer,",
						"          OrderID as integer,",
						"          DeliveryMethodID as integer,",
						"          ContactPersonID as integer,",
						"          AccountsPersonID as integer,",
						"          SalespersonPersonID as integer,",
						"          PackedByPersonID as integer,",
						"          InvoiceDate as date,",
						"          CustomerPurchaseOrderNumber as string,",
						"          IsCreditNote as boolean,",
						"          CreditNoteReason as string,",
						"          Comments as string,",
						"          DeliveryInstructions as string,",
						"          InternalComments as string,",
						"          TotalDryItems as integer,",
						"          TotalChillerItems as integer,",
						"          DeliveryRun as string,",
						"          RunPosition as string,",
						"          ReturnedDeliveryData as string,",
						"          ConfirmedDeliveryTime as timestamp,",
						"          ConfirmedReceivedBy as string,",
						"          LastEditedBy as integer,",
						"          LastEditedWhen as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> Invoices",
						"select1 aggregate(groupBy(CustomerID),",
						"     NumOfOrderPerCustomer = count(OrderID)) ~> CountOrdersPerCustomer",
						"OrdersODS select(mapColumn(",
						"          OrderID,",
						"          CustomerID,",
						"          SalespersonPersonID,",
						"          PickedByPersonID,",
						"          ContactPersonID,",
						"          BackorderOrderID,",
						"          OrderDate,",
						"          ExpectedDeliveryDate,",
						"          CustomerPurchaseOrderNumber,",
						"          IsUndersupplyBackordered,",
						"          Comments,",
						"          DeliveryInstructions,",
						"          InternalComments,",
						"          PickingCompletedWhen,",
						"          LastEditedBy,",
						"          LastEditedWhen",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"CountOrdersPerCustomer sort(desc(NumOfOrderPerCustomer, true)) ~> sort1",
						"OrderlinesODS select(mapColumn(",
						"          OrderLineID,",
						"          OrderID,",
						"          StockItemID,",
						"          Description,",
						"          PackageTypeID,",
						"          Quantity,",
						"          UnitPrice,",
						"          TaxRate,",
						"          PickedQuantity,",
						"          PickingCompletedWhen,",
						"          LastEditedBy,",
						"          LastEditedWhen",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2, select4 join(select2@StockItemID == select4@StockItemID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"select5 aggregate(groupBy(StockItemID),",
						"     SalesPerStockItem = sum(Quantity*UnitPrice)) ~> SalesPerStockItem",
						"SalesPerStockItem rank(desc(SalesPerStockItem, true),",
						"     caseInsensitive: true,",
						"     output(SalesRank as long),",
						"     dense: true) ~> rank1",
						"sort1, PeopleName join(CustomerID == PersonID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"People select(mapColumn(",
						"          PersonID,",
						"          FullName,",
						"          PhoneNumber,",
						"          EmailAddress",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PeopleName",
						"join2 select(mapColumn(",
						"          CustomerID,",
						"          NumOfOrderPerCustomer,",
						"          FullName,",
						"          PhoneNumber,",
						"          EmailAddress",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"StockItems, PackageTypes join(UnitPackageID == PackageTypeID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 select(mapColumn(",
						"          StockItemID,",
						"          StockItemName,",
						"          PackageTypeName",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"join1 select(mapColumn(",
						"          OrderID,",
						"          StockItemID = select2@StockItemID,",
						"          PackageTypeID,",
						"          Quantity,",
						"          UnitPrice,",
						"          StockItemID = select4@StockItemID,",
						"          StockItemName,",
						"          PackageTypeName",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"select6, select4 join(select6@StockItemID == select4@StockItemID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"rank1 select(mapColumn(",
						"          StockItemID,",
						"          SalesPerStockItem,",
						"          SalesRank",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"join4 select(mapColumn(",
						"          StockItemID = select4@StockItemID,",
						"          StockItemName,",
						"          SalesPerStockItem,",
						"          SalesRank,",
						"          PackageTypeName",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select7",
						"Invoices select(mapColumn(",
						"          InvoiceID,",
						"          CustomerID,",
						"          OrderID,",
						"          InvoiceDate,",
						"          DeliveryInstructions",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select8",
						"select8, PeopleName join(CustomerID == PersonID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"join5, select3 join(select8@CustomerID == select3@CustomerID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join6",
						"join6 select(mapColumn(",
						"          InvoiceID,",
						"          OrderID,",
						"          InvoiceDate,",
						"          PersonID,",
						"          FullName = PeopleName@FullName,",
						"          PhoneNumber = PeopleName@PhoneNumber,",
						"          EmailAddress = PeopleName@EmailAddress,",
						"          DeliveryInstructions",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select9",
						"select7 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink2",
						"select3 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink3",
						"select4 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink4"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MovieShop')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "RawToBronze",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "RawToBronze",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"IngestBronze": {},
									"Bronze": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "BronzeToSilver",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "RawToBronze",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "BronzeToSilver",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"IngestBronze": {},
									"MovieSilver": {
										"DicName": "adf_parquet_movie"
									},
									"sink3": {
										"DirectoryName": "adf_parquet_genres"
									},
									"sink5": {
										"DirectoryName": "adf_parquet_language"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-06-18T02:13:54Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/RawToBronze')]",
				"[concat(variables('factoryId'), '/dataflows/BronzeToSilver')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/trigger1')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "MovieShop",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Minute",
						"interval": 15,
						"startTime": "2022-06-17T00:17:00",
						"endTime": "2022-06-17T20:50:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/MovieShop')]"
			]
		}
	]
}